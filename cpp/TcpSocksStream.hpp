// Automatically generated by flapigen
#pragma once

//for assert
#include <cassert>
//for std::abort
#include <cstdlib>
//for std::move
#include <utility>
//for std::conditional
#include <type_traits>

#include "rust_str.h"
#include <boost/utility/string_view.hpp>
#include <stdint.h>
#include "DataObserver.hpp"
#include <memory>
#include <utility>
#include "c_DataObserver.h"
#include "rust_void_ok_resultCRustString.h"
#include <boost/variant.hpp>

#include "c_TcpSocksStream.h"

namespace sifir_lib {

template<bool>
class TcpSocksStreamWrapper;
using TcpSocksStream = TcpSocksStreamWrapper<true>;
using TcpSocksStreamRef = TcpSocksStreamWrapper<false>;


template<bool OWN_DATA>
class TcpSocksStreamWrapper {
public:
    using value_type = TcpSocksStreamWrapper<true>;
    friend class TcpSocksStreamWrapper<true>;
    friend class TcpSocksStreamWrapper<false>;

    using SelfType = typename std::conditional<OWN_DATA, TcpSocksStreamOpaque *, const TcpSocksStreamOpaque *>::type;
    using CForeignType = TcpSocksStreamOpaque;

    TcpSocksStreamWrapper(TcpSocksStreamWrapper &&o) noexcept: self_(o.self_)
    {
        o.self_ = nullptr;
    }
    TcpSocksStreamWrapper &operator=(TcpSocksStreamWrapper &&o) noexcept
    {
        assert(this != &o);
        free_mem(this->self_);
        self_ = o.self_;
        o.self_ = nullptr;
        return *this;
    }
    explicit TcpSocksStreamWrapper(SelfType o) noexcept: self_(o) {}
    TcpSocksStreamOpaque *release() noexcept
    {
        TcpSocksStreamOpaque *ret = self_;
        self_ = nullptr;
        return ret;
    }
    explicit operator SelfType() const noexcept { return self_; }
    TcpSocksStreamWrapper<false> as_rref() const noexcept { return TcpSocksStreamWrapper<false>{ self_ }; }
    const TcpSocksStreamWrapper<true> &as_cref() const noexcept { return reinterpret_cast<const TcpSocksStreamWrapper<true> &>(*this); }

    TcpSocksStreamWrapper(const TcpSocksStreamWrapper&) = delete;
    TcpSocksStreamWrapper &operator=(const TcpSocksStreamWrapper&) = delete;

    TcpSocksStreamWrapper(boost::string_view target, boost::string_view socks_proxy, uint64_t timeout_ms) noexcept
    {

        this->self_ = TcpSocksStream_new(CRustStrView{ target.data(), target.size() }, CRustStrView{ socks_proxy.data(), socks_proxy.size() }, timeout_ms);
        if (this->self_ == nullptr) {
            std::abort();
        }
    }

    boost::variant<void *, RustString> on_data(std::unique_ptr<DataObserver> cb) noexcept;

    boost::variant<void *, RustString> send_data(boost::string_view msg, uint64_t timeout) noexcept;

private:
   static void free_mem(SelfType &p) noexcept
   {
        if (OWN_DATA && p != nullptr) {
            TcpSocksStream_delete(p);
        }
        p = nullptr;
   }
public:
    ~TcpSocksStreamWrapper() noexcept
    {
        free_mem(this->self_);
    }

private:
    SelfType self_;
};


    template<bool OWN_DATA>
    inline boost::variant<void *, RustString> TcpSocksStreamWrapper<OWN_DATA>::on_data(std::unique_ptr<DataObserver> cb) noexcept
    {

        C_DataObserver tmp = DataObserver::to_c_interface(std::move(cb));
        const struct C_DataObserver * const a0 = &tmp;

        struct CRustVoidOkResultCRustString ret = TcpSocksStream_on_data(this->self_, std::move(a0));
        return ret.is_ok != 0 ?
            boost::variant<void *, RustString> { nullptr } :
            boost::variant<void *, RustString> { RustString{ret.data.err} };
    }

    template<bool OWN_DATA>
    inline boost::variant<void *, RustString> TcpSocksStreamWrapper<OWN_DATA>::send_data(boost::string_view msg, uint64_t timeout) noexcept
    {

        struct CRustVoidOkResultCRustString ret = TcpSocksStream_send_data(this->self_, CRustStrView{ msg.data(), msg.size() }, timeout);
        return ret.is_ok != 0 ?
            boost::variant<void *, RustString> { nullptr } :
            boost::variant<void *, RustString> { RustString{ret.data.err} };
    }

} // namespace sifir_lib
