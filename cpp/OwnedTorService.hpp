// Automatically generated by flapigen
#pragma once

//for assert
#include <cassert>
//for std::abort
#include <cstdlib>
//for std::move
#include <utility>
//for std::conditional
#include <type_traits>

#include "TorServiceParam.hpp"
#include "c_TorServiceParam.h"
#include <stdint.h>
#include "rust_str.h"
#include "rust_void_ok_resultCRustString.h"
#include <boost/variant.hpp>
#include <boost/utility/string_view.hpp>
#include "TorHiddenService.hpp"
#include "c_TorHiddenService.h"
#include "rust_result4232mut3232c_voidCRustString.h"

#include "c_OwnedTorService.h"

namespace sifir_lib {

template<bool>
class OwnedTorServiceWrapper;
using OwnedTorService = OwnedTorServiceWrapper<true>;
using OwnedTorServiceRef = OwnedTorServiceWrapper<false>;


template<bool OWN_DATA>
class OwnedTorServiceWrapper {
public:
    using value_type = OwnedTorServiceWrapper<true>;
    friend class OwnedTorServiceWrapper<true>;
    friend class OwnedTorServiceWrapper<false>;

    using SelfType = typename std::conditional<OWN_DATA, OwnedTorServiceOpaque *, const OwnedTorServiceOpaque *>::type;
    using CForeignType = OwnedTorServiceOpaque;

    OwnedTorServiceWrapper(OwnedTorServiceWrapper &&o) noexcept: self_(o.self_)
    {
        o.self_ = nullptr;
    }
    OwnedTorServiceWrapper &operator=(OwnedTorServiceWrapper &&o) noexcept
    {
        assert(this != &o);
        free_mem(this->self_);
        self_ = o.self_;
        o.self_ = nullptr;
        return *this;
    }
    explicit OwnedTorServiceWrapper(SelfType o) noexcept: self_(o) {}
    OwnedTorServiceOpaque *release() noexcept
    {
        OwnedTorServiceOpaque *ret = self_;
        self_ = nullptr;
        return ret;
    }
    explicit operator SelfType() const noexcept { return self_; }
    OwnedTorServiceWrapper<false> as_rref() const noexcept { return OwnedTorServiceWrapper<false>{ self_ }; }
    const OwnedTorServiceWrapper<true> &as_cref() const noexcept { return reinterpret_cast<const OwnedTorServiceWrapper<true> &>(*this); }

    OwnedTorServiceWrapper(const OwnedTorServiceWrapper&) = delete;
    OwnedTorServiceWrapper &operator=(const OwnedTorServiceWrapper&) = delete;

    OwnedTorServiceWrapper(TorServiceParam param) noexcept
    {

        this->self_ = OwnedTorService_new(param.release());
        if (this->self_ == nullptr) {
            std::abort();
        }
    }

    uint16_t getSocksPort() const noexcept;

    boost::variant<void *, RustString> shutdown() noexcept;

    RustString get_status() noexcept;

    boost::variant<TorHiddenService, RustString> create_hidden_service(uint16_t dst_port, uint16_t hs_port, boost::string_view secret_key) noexcept;

    boost::variant<void *, RustString> delete_hidden_service(boost::string_view onion) noexcept;

private:
   static void free_mem(SelfType &p) noexcept
   {
        if (OWN_DATA && p != nullptr) {
            OwnedTorService_delete(p);
        }
        p = nullptr;
   }
public:
    ~OwnedTorServiceWrapper() noexcept
    {
        free_mem(this->self_);
    }

private:
    SelfType self_;
};


    template<bool OWN_DATA>
    inline uint16_t OwnedTorServiceWrapper<OWN_DATA>::getSocksPort() const noexcept
    {

        uint16_t ret = OwnedTorService_getSocksPort(this->self_);
        return ret;
    }

    template<bool OWN_DATA>
    inline boost::variant<void *, RustString> OwnedTorServiceWrapper<OWN_DATA>::shutdown() noexcept
    {

        struct CRustVoidOkResultCRustString ret = OwnedTorService_shutdown(this->self_);
        return ret.is_ok != 0 ?
            boost::variant<void *, RustString> { nullptr } :
            boost::variant<void *, RustString> { RustString{ret.data.err} };
    }

    template<bool OWN_DATA>
    inline RustString OwnedTorServiceWrapper<OWN_DATA>::get_status() noexcept
    {

        struct CRustString ret = OwnedTorService_get_status(this->self_);
        return RustString{ret};
    }

    template<bool OWN_DATA>
    inline boost::variant<TorHiddenService, RustString> OwnedTorServiceWrapper<OWN_DATA>::create_hidden_service(uint16_t dst_port, uint16_t hs_port, boost::string_view secret_key) noexcept
    {

        struct CRustResult4232mut3232c_voidCRustString ret = OwnedTorService_create_hidden_service(this->self_, dst_port, hs_port, CRustStrView{ secret_key.data(), secret_key.size() });
        return ret.is_ok != 0 ?
              boost::variant<TorHiddenService, RustString> { TorHiddenService(static_cast<TorHiddenServiceOpaque *>(ret.data.ok)) } :
              boost::variant<TorHiddenService, RustString> { RustString{ret.data.err} };
    }

    template<bool OWN_DATA>
    inline boost::variant<void *, RustString> OwnedTorServiceWrapper<OWN_DATA>::delete_hidden_service(boost::string_view onion) noexcept
    {

        struct CRustVoidOkResultCRustString ret = OwnedTorService_delete_hidden_service(this->self_, CRustStrView{ onion.data(), onion.size() });
        return ret.is_ok != 0 ?
            boost::variant<void *, RustString> { nullptr } :
            boost::variant<void *, RustString> { RustString{ret.data.err} };
    }

} // namespace sifir_lib
